#
# This file is used to call the GUI generated by QT Designer and manage the updates of the different widgets
#
import pyqtgraph as pg
import numpy as np
from datetime import datetime, timedelta
import time
from random import randint
from multiprocessing import Process, Pipe

from GUI.ECG_GUI_QTDesigner import Ui_MainWindow  # GUI main Class and File
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QObject, QThread, pyqtSignal, Qt, QTimer
from PyQt5.QtWidgets import QDialog, QApplication


# global Objects and variables:
_translate = QtCore.QCoreApplication.translate
pipe_sender_PlotWidget, pipe_recipient_PlotWidget = Pipe()  # activate global data Pipe to send Serial data to Plots
pipe_sender_Numberfields, pipe_recipient_Numberfields = Pipe()  # activate global data Pipe to send Serial data to Numberfields



class Ui_Build(Ui_MainWindow):
    def __init__(self, MainWindow, SensorBoard):
        super().__init__()   # inheritances all GUI attributes and methods from GUI Main file
        self.setupUi(MainWindow)  # calls setup function from GUI file to build GUI

        # enabling Serial Connection to Sensor Board:
        self.SensorBoard = SensorBoard  # gets properties of Sensor Board passed

        self.SensorBoard.add_pipe(pipe_sender_PlotWidget, pipe_sender_Numberfields)

        # init Thread to read serial data:
        self.SerialData_Thread = QThread()
        self.SensorBoard.moveToThread(self.SerialData_Thread)
        self.SerialData_Thread.started.connect(self.SensorBoard.read_serial_data)
        self.SerialData_Thread.start()
        # adding Plots into Graphics Widget: HeartratePlot,SPO2Plot,AF_ETCO2_Plot:
        self.heartrate_curve_back = pg.PlotDataItem()
        self.heartrate_curve_front = pg.PlotDataItem()
        self.HeartratePlot.addItem(self.heartrate_curve_back)
        self.HeartratePlot.addItem(self.heartrate_curve_front)

        self.SPO2_curve_back = pg.PlotDataItem()
        self.SPO2_curve_front = pg.PlotDataItem()
        self.SPO2Plot.addItem(self.SPO2_curve_back)
        self.SPO2Plot.addItem(self.SPO2_curve_front)

        self.AF_curve_back = pg.PlotDataItem()
        self.AF_curve_front = pg.PlotDataItem()
        self.ETCO2_curve_back = pg.PlotDataItem()
        self.ETCO2_curve_front = pg.PlotDataItem()
        self.AF_ETCO2_Plot.addItem(self.AF_curve_back)
        self.AF_ETCO2_Plot.addItem(self.AF_curve_front)
        self.AF_ETCO2_Plot.addItem(self.ETCO2_curve_back)
        self.AF_ETCO2_Plot.addItem(self.ETCO2_curve_front)

        # init Thread for to update the header
        self.Header = GUI_HEADER()
        self.Header_Thread = QThread()
        self.Header.moveToThread(self.Header_Thread)
        self.Header.send_current_time_Signal.connect(self.Clock.setText, Qt.QueuedConnection)
        self.Header.send_StopWatch_Signal.connect(self.Stopwatch.setText, Qt.QueuedConnection)
        self.Header.send_date_Signal.connect(self.Date.setText, Qt.QueuedConnection)
        self.Header_Thread.started.connect(self.Header.update)
        self.Header_Thread.start()

        # init Thread for the number fields:
        self.NumberFields = GUI_NUMBERFIELDS(self.SensorBoard.serial_input_order)
        self.NumberFields_Thread = QThread()
        self.NumberFields.moveToThread(self.NumberFields_Thread)
        self.NumberFields.send_AF_Signal.connect(self.AF_value.setText, Qt.QueuedConnection)
        self.NumberFields.send_SPO2_Signal.connect(self.SPO2_value.setText, Qt.QueuedConnection)
        self.NumberFields.send_ETCO2_Signal.connect(self.ETCO2_value.setText, Qt.QueuedConnection)
        self.NumberFields.send_heartrate_Signal.connect(self.heartrate_value.setText, Qt.QueuedConnection)
        self.NumberFields_Thread.started.connect(self.NumberFields.update)
        self.NumberFields_Thread.start()

        # init Thread to update Plots:
        self.PlotFields = GUI_PLOTS(self.SensorBoard.serial_input_order)
        self.PlotFields_Thread = QThread()
        self.PlotFields.moveToThread(self.PlotFields_Thread)

        # set x-Axis Range:
        self.PlotFields.send_Plot_x_Range.connect(self.HeartratePlot.setXRange, Qt.QueuedConnection)
        self.PlotFields.send_Plot_x_Range.connect(self.SPO2Plot.setXRange, Qt.QueuedConnection)
        self.PlotFields.send_Plot_x_Range.connect(self.AF_ETCO2_Plot.setXRange, Qt.QueuedConnection)

        # connect Plot Signals:
        self.PlotFields.send_heartratePlot_Signal.connect(self.heartrate_curve_back.setData, Qt.QueuedConnection)
        self.PlotFields.send_heartratePlot_front_Signal.connect(self.heartrate_curve_front.setData, Qt.QueuedConnection)

        self.PlotFields.send_AF_Plot_Signal.connect(self.AF_curve_back.setData, Qt.QueuedConnection)
        self.PlotFields.send_AF_Plot_front_Signal.connect(self.AF_curve_front.setData, Qt.QueuedConnection)
        # self.PlotFields.send_ETCO2_Plot_Signal.connect(self.ETCO2_curve_back.setData, Qt.QueuedConnection)
        # self.PlotFields.send_ETCO2_Plot_front_Signal.connect(self.ETCO2_curve_front.setData, Qt.QueuedConnection)

        self.PlotFields.send_SPO2Plot_Signal.connect(self.SPO2_curve_back.setData, Qt.QueuedConnection)
        self.PlotFields.send_SPO2Plot_front_Signal.connect(self.SPO2_curve_front.setData, Qt.QueuedConnection)

        self.PlotFields_Thread.started.connect(self.PlotFields.update)
        self.PlotFields_Thread.start()

        #
        QApplication.sendPostedEvents()
        QApplication.processEvents()


class GUI_HEADER(QObject):
    send_current_time_Signal = pyqtSignal(str)  # init QThread Signal to send updated value for the Clock
    send_StopWatch_Signal = pyqtSignal(str)  # init QThread Signal to send updated value for the StopWatch
    send_date_Signal = pyqtSignal(str)  # init QThread Signal to send updated date to the GUI

    def __init__(self):
        super().__init__()
        self.time = datetime
        self.start_time = time.time()

    def update(self):
        # sends the date to the GUI
        self.send_date_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#ffffff;\">{date}</span></p></body></html>").format(date=self.time.now().date().today().strftime('%d.%m.%y')))
        while True: # init updating loop for the Clock and StopWatch of the GUI
            # Enable time convertion for stop watch:
            sec = time.time() - self.start_time
            mins = sec // 60
            sec = sec % 60
            hours = mins // 60
            mins = mins % 60
            # sends current values for Clock and Stop watch to the GUI
            self.send_current_time_Signal.emit(_translate("MainWindow", "<html><head/><body><p align=\"right\"><span style=\" color:#ffffff;\">{time}</span></p></body></html>".format(time=self.time.now().strftime("%H:%M:%S"))))
            self.send_StopWatch_Signal.emit(_translate("MainWindow","<html><head/><body><p align=\"center\"><span style=\" color:#ffffff;\">{:0>2}:{:0>2}:{:0>2}</span></p></body></html>".format(int(hours), int(mins), int(sec))))
            QApplication.sendPostedEvents()
            QApplication.processEvents()
            QThread.msleep(500)  # ms


class GUI_NUMBERFIELDS(QObject):
    send_heartrate_Signal = pyqtSignal(str)
    send_SPO2_Signal = pyqtSignal(str)
    send_ETCO2_Signal = pyqtSignal(str)
    send_AF_Signal = pyqtSignal(str)

    def __init__(self, serial_input_order):
        super().__init__()
        self.serial_input_order = serial_input_order

        # init Serial Input Signals
        self.incoming_Data = np.ndarray
        # set input data checks:
        self.Heartrate_enabled = False
        self.SPO2_enabled = False
        self.AF_enabled = False
        self.ETCO2_enabled = False
        #
        # Check, if Plot data is incoming and find data index of serial input:
        if "Heartrate" in self.serial_input_order:
            self.Heartrate_index = self.serial_input_order.index("Heartrate")
            self.Heartrate_enabled = True
        if "SPO2" in self.serial_input_order:
            self.SPO2_index = self.serial_input_order.index("SPO2")
            self.SPO2_enabled = True
        if "ETCO2" in self.serial_input_order:
            self.ETCO2_index = self.serial_input_order.index("ETCO2")
            self.ETCO2_enabled = True
        if "AF" in self.serial_input_order:
            self.AF_index = self.serial_input_order.index("AF")
            self.AF_enabled = True

    def update(self):
        while True:
            self.incoming_Data = pipe_recipient_Numberfields.recv()

            if self.Heartrate_enabled:
                self.send_heartrate_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#ff0000;\">{heartrate}</span></p></body></html>".format(heartrate=self.incoming_Data[self.Heartrate_index])))
            else:
                self.send_heartrate_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#ff0000;\">--</span></p></body></html>"))
            if self.SPO2_enabled:
                self.send_SPO2_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#ffff00;\">{SPO2}</span></p></body></html>".format(SPO2=self.incoming_Data[self.SPO2_index])))
            else:
                self.send_SPO2_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#ffff00;\">--</span></p></body></html>"))
            if self.ETCO2_enabled:
                self.send_AF_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#55ff7f;\">{AF}</span></p></body></html>".format(AF=self.incoming_Data[self.AF_index])))
            else:
                self.send_AF_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#55ff7f;\">--</span></p></body></html>"))
            if self.AF_enabled:
                self.send_ETCO2_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">{ETCO2}</span></p></body></html>".format(ETCO2=self.incoming_Data[self.ETCO2_index])))
            else:
                self.send_ETCO2_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">--</span></p></body></html>"))


class GUI_PLOTS(QObject):
    # enable Plot Signals:
    send_heartratePlot_Signal = pyqtSignal(np.ndarray, np.ndarray)
    send_heartratePlot_front_Signal = pyqtSignal(np.ndarray, np.ndarray)

    send_AF_Plot_Signal = pyqtSignal(np.ndarray, np.ndarray)
    send_AF_Plot_front_Signal = pyqtSignal(np.ndarray, np.ndarray)

    send_ETCO2_Plot_Signal = pyqtSignal(np.ndarray, np.ndarray)
    send_ETCO2_Plot_front_Signal = pyqtSignal(np.ndarray, np.ndarray)

    send_SPO2Plot_Signal = pyqtSignal(np.ndarray, np.ndarray)
    send_SPO2Plot_front_Signal = pyqtSignal(np.ndarray, np.ndarray)

    send_Plot_x_Range = pyqtSignal(int, int)
    send_Plot_x_front_Signal = pyqtSignal(int, int)

    def __init__(self, serial_input_order):
        super().__init__()
        self.serial_input_order = serial_input_order
        # generate start arrays for input data:
        self.Heartrate_Data_new = np.zeros(401)
        self.SPO2_Data_new = np.zeros(401)
        self.ETCO2_Data_new = np.zeros(401)
        self.AF_Data_new = np.zeros(401)

        # set x-axis:
        self.x_axis_Data = np.zeros(401)
        self.x_axis_Data = np.arange(0, 401, 1)  # x Data
        self.datapoint = 200

        # set input data checks:
        self.Heartrate_enabled = False
        self.SPO2_enabled = False
        self.AF_enabled = False
        self.ETCO2_enabled = False

        # Check, if Plot data is incoming and find data index of serial input:
        if "Heartrate" in self.serial_input_order:
            self.Heartrate_index = self.serial_input_order.index("Heartrate")
            self.Heartrate_enabled = True
        if "SPO2" in self.serial_input_order:
            self.SPO2_index = self.serial_input_order.index("SPO2")
            self.SPO2_enabled = True
        if "ETCO2" in self.serial_input_order:
            self.ETCO2_index = self.serial_input_order.index("ETCO2")
            self.ETCO2_enabled = True
        if "AF" in self.serial_input_order:
            self.AF_index = self.serial_input_order.index("AF")
            self.AF_enabled = True

    def update(self):
        while True:
            if self.datapoint <= 400:
                # read input Data if enabled:
                if self.Heartrate_enabled:
                    self.Heartrate_Data_new[self.datapoint] = pipe_recipient_PlotWidget.recv()[self.Heartrate_index]
                else:
                    self.Heartrate_Data_new[self.datapoint] = 0  # TODO: change this routine
                if self.SPO2_enabled:
                    self.SPO2_Data_new[self.datapoint] = pipe_recipient_PlotWidget.recv()[self.SPO2_index]
                else:
                    self.SPO2_Data_new[self.datapoint] = 0
                if self.ETCO2_enabled:
                    self.ETCO2_Data_new[self.datapoint] = pipe_recipient_PlotWidget.recv()[self.ETCO2_index]
                else:
                    self.self.ETCO2_Data_new[self.datapoint] = 0
                if self.AF_enabled:
                    self.AF_Data_new[self.datapoint] = pipe_recipient_PlotWidget.recv()[self.AF_index]
                else:
                    self.AF_Data_new[self.datapoint] = 0
                # set new datapoint
                self.datapoint += 1
            else:
                self.datapoint = 0  # reset datapoint -> start plotting from beginning

            self.send_heartratePlot_Signal.emit(self.x_axis_Data[0:self.datapoint], self.Heartrate_Data_new[0:self.datapoint])
            self.send_heartratePlot_front_Signal.emit(self.x_axis_Data[self.datapoint + 2:-1], self.Heartrate_Data_new[self.datapoint + 2:-1])

            self.send_AF_Plot_Signal.emit(self.x_axis_Data[0:self.datapoint], self.AF_Data_new[0:self.datapoint])
            self.send_AF_Plot_front_Signal.emit(self.x_axis_Data[self.datapoint + 2:-1], self.AF_Data_new[self.datapoint + 2:-1])

            self.send_SPO2Plot_Signal.emit(self.x_axis_Data[0:self.datapoint], self.SPO2_Data_new[0:self.datapoint])
            self.send_SPO2Plot_front_Signal.emit(self.x_axis_Data[self.datapoint + 2:-1], self.SPO2_Data_new[self.datapoint + 2:-1])

            self.send_ETCO2_Plot_Signal.emit(self.x_axis_Data[0:self.datapoint], self.ETCO2_Data_new[0:self.datapoint])
            self.send_ETCO2_Plot_front_Signal.emit(self.x_axis_Data[self.datapoint + 2:-1], self.ETCO2_Data_new[self.datapoint + 2:-1])

            self.send_Plot_x_Range.emit(0, 401)  # TODO: Why does it have to be in the Loop ?





