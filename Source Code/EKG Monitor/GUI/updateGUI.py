#
# This file is used to call the GUI generated by QT Designer and manage the updates of the different widgets
#
import pyqtgraph as pg
import numpy as np
from datetime import datetime, timedelta
import time
from random import randint
from multiprocessing import Process, Pipe

from GUI.ECG_GUI_QTDesigner import Ui_MainWindow  # GUI main Class and File
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QObject, QThread, pyqtSignal, Qt, QTimer
from PyQt5.QtWidgets import QDialog, QApplication


# global Objects and variables:
_translate = QtCore.QCoreApplication.translate
pipe_sender_PlotWidget, pipe_recipient_PlotWidget = Pipe()  # activate global data Pipe to send Serial data to Plots
pipe_sender_Numberfields, pipe_recipient_Numberfields = Pipe()  # activate global data Pipe to send Serial data to Numberfields



class Ui_Build(Ui_MainWindow):
    def __init__(self, MainWindow, SensorBoard):
        super().__init__()   # inheritances all GUI attributes and methods from GUI Main file
        self.setupUi(MainWindow)  # calls setup function from GUI file to build GUI

        # enabling Serial Connection to Sensor Board:
        self.SensorBoard = SensorBoard  # gets properties of Sensor Board passed

        self.SensorBoard.add_pipe(pipe_sender_PlotWidget, pipe_sender_Numberfields)

        # init Thread to read serial data:
        self.SerialData_Thread = QThread()
        self.SensorBoard.moveToThread(self.SerialData_Thread)
        self.SerialData_Thread.started.connect(self.SensorBoard.read_serial_data)
        self.SerialData_Thread.start()
        # adding Plots into Graphics Widget: HeartratePlot,SPO2Plot,AF_ETCO2_Plot:
        self.heartrate_curve_back = pg.PlotDataItem()
        self.heartrate_curve_front = pg.PlotDataItem()
        self.HeartratePlot.addItem(self.heartrate_curve_back)
        self.HeartratePlot.addItem(self.heartrate_curve_front)

        self.SPO2_curve_back = pg.PlotDataItem()
        self.SPO2_curve_front = pg.PlotDataItem()
        self.SPO2Plot.addItem(self.SPO2_curve_back)
        self.SPO2Plot.addItem(self.SPO2_curve_front)

        self.AF_curve_back = pg.PlotDataItem()
        self.AF_curve_front = pg.PlotDataItem()
        self.ETCO2_curve_back = pg.PlotDataItem()
        self.ETCO2_curve_front = pg.PlotDataItem()
        self.AF_ETCO2_Plot.addItem(self.AF_curve_back)
        self.AF_ETCO2_Plot.addItem(self.AF_curve_front)
        self.AF_ETCO2_Plot.addItem(self.ETCO2_curve_back)
        self.AF_ETCO2_Plot.addItem(self.ETCO2_curve_front)

        # init Thread for to update the header
        self.Header = GUI_HEADER()
        self.Header_Thread = QThread()
        self.Header.moveToThread(self.Header_Thread)
        self.Header.get_current_time_Signal.connect(self.Clock.setText, Qt.QueuedConnection)
        self.Header.get_StopWatch_Signal.connect(self.Stopwatch.setText, Qt.QueuedConnection)
        self.Header.get_date_Signal.connect(self.Date.setText, Qt.QueuedConnection)
        self.Header_Thread.started.connect(self.Header.update)
        self.Header_Thread.start()

        # init Thread for the number fields:
        self.NumberFields = GUI_NUMBERFIELDS(self.SensorBoard.serial_input_order)
        self.NumberFields_Thread = QThread()
        self.NumberFields.moveToThread(self.NumberFields_Thread)
        self.NumberFields.get_AF_Signal.connect(self.AF_value.setText, Qt.QueuedConnection)
        self.NumberFields.get_SPO2_Signal.connect(self.SPO2_value.setText, Qt.QueuedConnection)
        self.NumberFields.get_ETCO2_Signal.connect(self.ETCO2_value.setText, Qt.QueuedConnection)
        self.NumberFields.get_heartrate_Signal.connect(self.heartrate_value.setText, Qt.QueuedConnection)
        self.NumberFields_Thread.started.connect(self.NumberFields.update)
        self.NumberFields_Thread.start()

        # init Thread to update Plots:
        self.PlotFields = GUI_PLOTS(self.SensorBoard.serial_input_order)
        self.PlotFields_Thread = QThread()
        self.PlotFields.moveToThread(self.PlotFields_Thread)

        # connect Plot Signals:
        self.PlotFields.get_heartratePlot_Signal.connect(self.heartrate_curve_back.setData, Qt.QueuedConnection)
        self.PlotFields.get_heartratePlot_front_Signal.connect(self.heartrate_curve_front.setData, Qt.QueuedConnection)

        self.PlotFields.get_AF_Plot_Signal.connect(self.AF_curve_back.setData, Qt.QueuedConnection)
        self.PlotFields.get_AF_Plot_front_Signal.connect(self.AF_curve_front.setData, Qt.QueuedConnection)
        # self.PlotFields.get_ETCO2_Plot_Signal.connect(self.ETCO2_curve_back.setData, Qt.QueuedConnection)
        # self.PlotFields.get_ETCO2_Plot_front_Signal.connect(self.ETCO2_curve_front.setData, Qt.QueuedConnection)

        self.PlotFields.get_SPO2Plot_Signal.connect(self.SPO2_curve_back.setData, Qt.QueuedConnection)
        self.PlotFields.get_SPO2Plot_front_Signal.connect(self.SPO2_curve_front.setData, Qt.QueuedConnection)

        self.PlotFields_Thread.started.connect(self.PlotFields.update_Plots)
        self.PlotFields_Thread.start()

        # set x-Axis Range:
        self.PlotFields.get_Plot_x_Range_Signal.connect(self.HeartratePlot.setXRange, Qt.QueuedConnection)
        self.PlotFields.get_Plot_x_Range_Signal.connect(self.SPO2Plot.setXRange, Qt.QueuedConnection)
        self.PlotFields.get_Plot_x_Range_Signal.connect(self.AF_ETCO2_Plot.setXRange, Qt.QueuedConnection)
        # set y-Axis Range:
        self.PlotFields.get_Plot_y_Range_Signal.connect(self.HeartratePlot.setYRange, Qt.QueuedConnection)
        self.PlotFields.get_Plot_y_Range_Signal.connect(self.SPO2Plot.setYRange, Qt.QueuedConnection)
        self.PlotFields.get_Plot_y_Range_Signal.connect(self.AF_ETCO2_Plot.setYRange, Qt.QueuedConnection)

        # init Slider:
        self.x_Axis_Slider.valueChanged.connect(self.update_PlotFields_x_axis, Qt.QueuedConnection)
        self.x_Axis_Slider.valueChanged.connect(self.x_Axis_Slider_value.display, Qt.QueuedConnection)
        self.x_Axis_Slider.valueChanged.connect(self.update_vector_length, Qt.QueuedConnection)

        self.y_Axis_Slider.valueChanged.connect(self.update_PlotFields_y_axis, Qt.QueuedConnection)
        self.y_Axis_Slider.valueChanged.connect(self.y_Axis_Slider_value.display, Qt.QueuedConnection)

        # init CheckBoxes:
        self.heartrate_CheckBox.stateChanged.connect(self.update_Heartrate_enabled)
        self.SPO2_CheckBox.stateChanged.connect(self.update_SPO2_enabled)
        self.AF_CheckBox.stateChanged.connect(self.update_AF_enabled)
        self.ETCO2_CheckBox.stateChanged.connect(self.update_ETCO2_enabled)

        # init progress bar of SPO2:
        self.PlotFields.get_SPO2_Progress_Bar_Signal.connect(self.SPO2_progress_bar.setValue)
        #
        QApplication.sendPostedEvents()
        QApplication.processEvents()

    def update_PlotFields_x_axis(self, value): self.PlotFields.get_Plot_x_Range_Signal.emit(0, value)
    def update_PlotFields_y_axis(self, value): self.PlotFields.get_Plot_y_Range_Signal.emit(-value, value)  # TODO: Does not work if Values are not the same range
    def update_vector_length(self, value): self.PlotFields.update_vector_length(value)

    def update_Heartrate_enabled(self, value): self.PlotFields.update_Heartrate_enabled(value)
    def update_SPO2_enabled(self, value): self.PlotFields.update_SPO2_enabled(value)
    def update_AF_enabled(self, value): self.PlotFields.update_AF_enabled(value)
    def update_ETCO2_enabled(self, value): self.PlotFields.update_ETCO2_enabled(value)


class GUI_HEADER(QObject):
    get_current_time_Signal = pyqtSignal(str)  # init QThread Signal to send updated value for the Clock
    get_StopWatch_Signal = pyqtSignal(str)  # init QThread Signal to send updated value for the StopWatch
    get_date_Signal = pyqtSignal(str)  # init QThread Signal to send updated date to the GUI

    def __init__(self):
        super().__init__()
        self.time = datetime
        self.start_time = time.time()

    def update(self):
        # sends the date to the GUI
        self.get_date_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#ffffff;\">{date}</span></p></body></html>").format(date=self.time.now().date().today().strftime('%d.%m.%y')))
        while True: # init updating loop for the Clock and StopWatch of the GUI
            # Enable time convertion for stop watch:
            sec = time.time() - self.start_time
            mins = sec // 60
            sec = sec % 60
            hours = mins // 60
            mins = mins % 60
            # sends current values for Clock and Stop watch to the GUI
            self.get_current_time_Signal.emit(_translate("MainWindow", "<html><head/><body><p align=\"right\"><span style=\" color:#ffffff;\">{time}</span></p></body></html>".format(time=self.time.now().strftime("%H:%M:%S"))))
            self.get_StopWatch_Signal.emit(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" color:#ffffff;\">{:0>2}:{:0>2}:{:0>2}</span></p></body></html>".format(int(hours), int(mins), int(sec))))
            QApplication.sendPostedEvents()
            QApplication.processEvents()
            QThread.msleep(500)  # ms


class GUI_NUMBERFIELDS(QObject):
    get_heartrate_Signal = pyqtSignal(str)
    get_SPO2_Signal = pyqtSignal(str)
    get_ETCO2_Signal = pyqtSignal(str)
    get_AF_Signal = pyqtSignal(str)

    def __init__(self, serial_input_order):
        super().__init__()
        self.serial_input_order = serial_input_order

        # init Serial Input Signals
        self.incoming_Data = np.ndarray
        # set input data checks:
        self.Heartrate_enabled = False
        self.SPO2_enabled = False
        self.AF_enabled = False
        self.ETCO2_enabled = False
        #
        # Check, if Plot data is incoming and find data index of serial input:
        if "Heartrate" in self.serial_input_order:
            self.Heartrate_index = self.serial_input_order.index("Heartrate")
            self.Heartrate_enabled = True
        if "SPO2" in self.serial_input_order:
            self.SPO2_index = self.serial_input_order.index("SPO2")
            self.SPO2_enabled = True
        if "ETCO2" in self.serial_input_order:
            self.ETCO2_index = self.serial_input_order.index("ETCO2")
            self.ETCO2_enabled = True
        if "AF" in self.serial_input_order:
            self.AF_index = self.serial_input_order.index("AF")
            self.AF_enabled = True

    def update(self):
        while True:
            self.incoming_Data = pipe_recipient_Numberfields.recv()

            if self.Heartrate_enabled:
                self.get_heartrate_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#ff0000;\">{heartrate}</span></p></body></html>".format(heartrate=self.incoming_Data[self.Heartrate_index])))
            else:
                self.get_heartrate_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#ff0000;\">--</span></p></body></html>"))
            if self.SPO2_enabled:
                self.get_SPO2_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#ffff00;\">{SPO2}</span></p></body></html>".format(SPO2=self.incoming_Data[self.SPO2_index])))
            else:
                self.get_SPO2_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#ffff00;\">--</span></p></body></html>"))
            if self.ETCO2_enabled:
                self.get_AF_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#55ff7f;\">{AF}</span></p></body></html>".format(AF=self.incoming_Data[self.AF_index])))
            else:
                self.get_AF_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#55ff7f;\">--</span></p></body></html>"))
            if self.AF_enabled:
                self.get_ETCO2_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">{ETCO2}</span></p></body></html>".format(ETCO2=self.incoming_Data[self.ETCO2_index])))
            else:
                self.get_ETCO2_Signal.emit(_translate("MainWindow", "<html><head/><body><p><span style=\" color:#0000ff;\">--</span></p></body></html>"))


class GUI_PLOTS(QObject):
    # enable Plot Signals:
    get_heartratePlot_Signal = pyqtSignal(np.ndarray, np.ndarray)
    get_heartratePlot_front_Signal = pyqtSignal(np.ndarray, np.ndarray)

    get_AF_Plot_Signal = pyqtSignal(np.ndarray, np.ndarray)
    get_AF_Plot_front_Signal = pyqtSignal(np.ndarray, np.ndarray)

    get_ETCO2_Plot_Signal = pyqtSignal(np.ndarray, np.ndarray)
    get_ETCO2_Plot_front_Signal = pyqtSignal(np.ndarray, np.ndarray)

    get_SPO2Plot_Signal = pyqtSignal(np.ndarray, np.ndarray)
    get_SPO2Plot_front_Signal = pyqtSignal(np.ndarray, np.ndarray)

    get_Plot_x_Range_Signal = pyqtSignal(int, int)
    get_Plot_y_Range_Signal = pyqtSignal(int, int)

    get_SPO2_Progress_Bar_Signal = pyqtSignal(int)

    def __init__(self, serial_input_order):
        super().__init__()
        self.serial_input_order = serial_input_order  # returns the Order of the incoming Data values
        self.init_vector_length = 400  # sets initial length of the Data Arrays
        self.vector_length = self.init_vector_length  # sets the default value for the Slider TODO: need to be changed if slider value is changed
        # generate start arrays for input data:
        self.Heartrate_Data_new = np.zeros(self.init_vector_length)
        self.SPO2_Data_new = np.zeros(self.init_vector_length)
        self.ETCO2_Data_new = np.zeros(self.init_vector_length)
        self.AF_Data_new = np.zeros(self.init_vector_length)

        # set x-axis:
        self.x_axis_Data = np.zeros(self.init_vector_length)
        self.x_axis_Data = np.arange(0, self.init_vector_length, 1)  # x Data
        self.datapoint = int(self.init_vector_length/2)  # init start Position of first Value displayed in Plot, starts in middle of the Plot

        # set input data checks:
        self.Heartrate_enabled = False
        self.SPO2_enabled = False
        self.AF_enabled = False
        self.ETCO2_enabled = False

        # Check, if Plot data is incoming and find data index of serial input:
        if "Heartrate" in self.serial_input_order:
            self.Heartrate_index = self.serial_input_order.index("Heartrate")
            self.Heartrate_enabled = True
        if "SPO2" in self.serial_input_order:
            self.SPO2_index = self.serial_input_order.index("SPO2")
            self.SPO2_enabled = True
        if "ETCO2" in self.serial_input_order:
            self.ETCO2_index = self.serial_input_order.index("ETCO2")
            self.ETCO2_enabled = True
        if "AF" in self.serial_input_order:
            self.AF_index = self.serial_input_order.index("AF")
            self.AF_enabled = True

    def update_vector_length(self, value):  # TODO: relate to time displayed
        """When Slider is used, this functions changes the length of the Arrays, which hold the Serial Data.
        Length = Value of the Slider """
        self.vector_length = value
        if value > self.Heartrate_Data_new.__len__():
            self.Heartrate_Data_new = np.insert(self.Heartrate_Data_new[0:self.init_vector_length], -1, np.zeros(self.vector_length-self.init_vector_length))
            self.SPO2_Data_new = np.insert(self.SPO2_Data_new[0:self.init_vector_length], -1, np.zeros(self.vector_length-self.init_vector_length))
            self.AF_Data_new = np.insert(self.AF_Data_new[0:self.init_vector_length], -1, np.zeros(self.vector_length-self.init_vector_length))
            self.ETCO2_Data_new = np.insert(self.ETCO2_Data_new[0:self.init_vector_length], -1, np.zeros(self.vector_length-self.init_vector_length))
            self.x_axis_Data = np.arange(0, self.Heartrate_Data_new.__len__(), 1)
            # time.sleep(0.05)
        if value < self.Heartrate_Data_new.__len__():
            self.SPO2_Data_new = self.SPO2_Data_new[0:self.vector_length]
            self.AF_Data_new = self.AF_Data_new[0:self.vector_length]
            self.ETCO2_Data_new = self.ETCO2_Data_new[0:self.vector_length]
            self.Heartrate_Data_new = self.Heartrate_Data_new[0:self.vector_length]
            self.x_axis_Data = np.arange(0, self.Heartrate_Data_new.__len__(), 1)


    def update_Heartrate_enabled(self, value): self.Heartrate_enabled = value
    """disables and enables if the Heartrate plot is shown (related to CheckBoxes), origin: updateGUI"""
    def update_SPO2_enabled(self, value): self.SPO2_enabled = value
    """disables and enables if the SPO2 plot is shown (related to CheckBoxes), origin: updateGUI"""
    def update_ETCO2_enabled(self, value): self.ETCO2_enabled = value
    """disables and enables if the ETCO2 plot is shown (related to CheckBoxes), origin: updateGUI"""
    def update_AF_enabled(self, value): self.AF_enabled = value
    """disables and enables if the AF plot is shown (related to CheckBoxes), origin: updateGUI"""

    def update_Plots(self):
        while True:
            if self.datapoint < self.Heartrate_Data_new.__len__()-1:
                # read input Data if enabled:
                if self.Heartrate_enabled:
                    self.Heartrate_Data_new[self.datapoint] = pipe_recipient_PlotWidget.recv()[self.Heartrate_index]
                else:
                    self.Heartrate_Data_new[self.datapoint] = 0  # TODO: change this routine
                if self.SPO2_enabled:
                    self.SPO2_Data_new[self.datapoint] = pipe_recipient_PlotWidget.recv()[self.SPO2_index]
                else:
                    self.SPO2_Data_new[self.datapoint] = 0
                if self.ETCO2_enabled:
                    self.ETCO2_Data_new[self.datapoint] = pipe_recipient_PlotWidget.recv()[self.ETCO2_index]
                else:
                    self.ETCO2_Data_new[self.datapoint] = 0
                if self.AF_enabled:
                    self.AF_Data_new[self.datapoint] = pipe_recipient_PlotWidget.recv()[self.AF_index]
                else:
                    self.AF_Data_new[self.datapoint] = 0
                if not(self.AF_enabled or self.SPO2_enabled or self.AF_enabled or self.ETCO2_enabled):
                    time.sleep(0.01)  # if now data is displayed, update time would be too fast

                self.datapoint += 1  # set new datapoint
            else:
                self.datapoint = 0  # reset datapoint -> start plotting from beginning

            self.get_heartratePlot_Signal.emit(self.x_axis_Data[0:self.datapoint], self.Heartrate_Data_new[0:self.datapoint])
            self.get_heartratePlot_front_Signal.emit(self.x_axis_Data[self.datapoint + 1:-1], self.Heartrate_Data_new[self.datapoint + 1:-1])

            self.get_AF_Plot_Signal.emit(self.x_axis_Data[0:self.datapoint], self.AF_Data_new[0:self.datapoint])
            self.get_AF_Plot_front_Signal.emit(self.x_axis_Data[self.datapoint + 1:-1], self.AF_Data_new[self.datapoint + 1:-1])

            self.get_SPO2Plot_Signal.emit(self.x_axis_Data[0:self.datapoint], self.SPO2_Data_new[0:self.datapoint])
            self.get_SPO2Plot_front_Signal.emit(self.x_axis_Data[self.datapoint + 1:-1], self.SPO2_Data_new[self.datapoint + 1:-1])

            self.get_ETCO2_Plot_Signal.emit(self.x_axis_Data[0:self.datapoint], self.ETCO2_Data_new[0:self.datapoint])
            self.get_ETCO2_Plot_front_Signal.emit(self.x_axis_Data[self.datapoint + 1:-1], self.ETCO2_Data_new[self.datapoint + 1:-1])

            self.get_SPO2_Progress_Bar_Signal.emit(int(self.SPO2_Data_new[self.datapoint-1]))



 # TODO: Add Textbox in Plot, showing NO SIGNAL if Datastream is disabled or 0
 # TODO: Add initial x-Axis scale, to get rid of the interruption at the end of the Plot
 # TODO: Disable y-Axis scaling
